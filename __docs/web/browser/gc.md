# 一文讲清楚 js 垃圾回收


## 什么是垃圾回收
所谓垃圾回收，无非就是我们使用一个东西，用完了，不需要继续使用了，那么可以回收这部分资源，重新拿来创造价值。我们这里要说的垃圾回收，特指的就是对不需要使用到的内存资源的释放。当前应用所占用的内存释放后，就可以提供给其它程序继续使用了。

一般来说，内存的使用周期是：分配 - 使用 - 释放

我们创建一个变量，创建的过程就是分配内存使用空间的过程，使用完成后无需使用了，就可以告诉操作系统，这东西我后面不需要了，你拿回去给其他程序用吧 ~

而释放的方式可以分为两种：
1. 手工释放
2. GC 自动回收
  
在 C 语言中，内存的分配和释放是需要程序员手动去进行的。但在像 java、JavaScript 这样的语言的执行引擎里面，就内置了 GC 进行自动的垃圾回收。

那如果不回收会怎么样呢？

如果一个程序占用到的内存使用完了，但是不释放，那么其他程序就无法使用这个内存空间，导致最后内存空间不够用的状况（但实际上可能是够用的，但就是有程序占着坑）。占用着内存空间不释放，也叫做 **内存泄漏**。


## js 内存模型

要了解 js 是如何进行垃圾回收的，我们需要先了解一下，js中的内存是如何分配使用的。

这里咱们抓大放小，简单来说，js的内存模型分为三部分：代码空间、栈空间、堆空间

栈空间中就是一个个的执行上下文栈，一段脚本或函数的执行就会创建一个对应的上下文，压入栈空间中，函数执行完成后，从栈空间中弹出执行上下文。

JS 的数据类型有 8 种（Null、Undefined、Boolean、Number、String、BigInt、Symbol、Object），7 个原始数据类型和一个对象类型。原始数据类型存储在栈空间中的执行上下文里，而对象类型的数据存储在堆空间中。这里需要注意，对象类型的实际数据存储在了堆空间中，但也会在栈空间里保留其内存地址作为引用。如果没有这个引用，这个对象就是无法获取到的，GC 会将无法获取到的对象当做垃圾处理。

## 栈空间中的垃圾回收
栈空间的垃圾回收其实很简单，得益于栈空间的特性，真正有用的数据都是在栈顶指针的下面的，其上的就是没用的数据了。栈空间的垃圾回收，实际只需要将栈顶指针向下移动即可，比如当前一个函数执行完成后，需要弹出其执行上下文，回收其执行上下文占用的空间。此时将栈顶指针下移到它的上一个执行上下文的地址即可。

移动完成后，其上的内存空间就等于是被回收了。这里说明一下，回收不一定是真的要对内存做什么特殊操作，而是告诉操作系统这块儿内存我没用到了，你可以随便折腾。如果后续又有函数执行，那么新的执行上下文入栈就会覆盖之前的数据，内存也就被新的执行上下文所使用了。

## 堆空间中的垃圾回收
堆空间的垃圾回收就没栈空间那么省事儿了。堆空间的回收都是通过垃圾回收器 GC 来完成的，GC 的实际回收算法各有不同，但 GC 的核心操作步骤都是这三步：**标记-清除-整理**。

所谓标记，就是去遍历内存空间，标记哪些内存是正在使用的，哪些是没用的。具体怎么遍历呢，其实就是看栈空间中有没有对堆空间中内存的引用，有引用的就是正在使用的活动空间，那么其它的就是该被回收的垃圾空间了。

清除可以理解为回收内存的使用权，当前程序没有使用，其它程序你可以拿去用了。

整理主要是指对 **内存碎片** 的整理。在进行垃圾回收后，活动的内存空间是遍布在内存中各个地方的，不连续的。这会导致有的时候程序需要一大块连续内存的时候申请内存失败，但实际的内存剩余空间是完全够的。这种不连续的散布于各处的内存使用状态，就是 “内存碎片”。解决方法就是将不连续的内存都堆到一起，成为连续内存，这就是内存整理了。整理完成后就会有大块的连续内存可供程序使用了。

### 代际假说

分代收集


- 主垃圾回收器：负责老生代的垃圾回收
- 副垃圾回收器：负责新生代的垃圾回收


### 新生代垃圾回收


### 老生代垃圾回收


### 特殊点讲解



## 如何利用好垃圾回收